# 서문
> 코드는 순차(sequence), 조건(selection), 반복(iteration)의 연속된 집합일 뿐입니다.

과거의 프로그래머가 현대의 코드를 이해하고 작성하는데 하루면 가능합니다. 반대로 현대의 프로그래머가 과거의 코드를 이해하고 작성하는데도 하루면 충분해요.

Java가 C와 크게 다르지 않고, 초당 10개의 문자를 전송하는 텔레타이프로 종이테이프에 구멍을 뚫어 PDP-8 코드를 작성하고 편집하는 방식도 다르지 않습니다. 코드는 그다지 바뀌지 않았기 때문입니다.

이게 열쇠인데, 코드가 변하지 않았다는 사실은 시스템의 종류와 관계없이 소프트웨어 아키텍처의 규칙이 일관된 이유입니다.

소프트웨어 아키텍처의 규칙이란 **프로그램의 구성요소를 정렬하고 조립하는 방법에 관한 규칙**입니다. 구성요소가 보편적이며 변하지 않았으므로 이를 정렬하는 규칙 역시도 보편적이며 변한 것은 없어요.

# 1부 : 소개
## 1장, 설계와 아키텍처란
> 설계와 아키텍처는 단절 없이 이어진 직물과 같으며 이를 통해 대상 시스템의 구조를 정의합니다.

- 아키텍처(architecture) : 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용
- 설계(design) : 저수준의 구조 또는 결정사항 등을 의미

단, 아키텍트가 실제로 하는 일로써 이 둘을 구분하는 것은 무의미합니다. 고수준의 결정사항을 지탱하는 저수준의 세부사항이 전체 설계의 구성요소가 되기 때문이에요.

이들의 목표는 하나입니다. **필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화**하는 데 말이죠.

2006년, 이솝은 토끼와 거북이 우화를 지었는데 이 교훈은 다양한 형태로 이어져 내려왔습니다.
- 느려도 꾸준하면 이긴다.
- 발 빠른 자가 경주에 이기는 것도, 힘이 센 자가 싸움에서 이기는 것도 아니다.
- 급할수록 돌아가라.

이 우화는 `과신이 가진 어리석음`을 말해줍니다. 현대의 개발자들도 우화의 토끼와 비슷한 과신을 드러내요. 잠을 잔다라는 측면이 아니라, 흔해 빠진 "코드는 나중에 정리하면 돼. 당장은 시장에 출시하는 게 먼저야!"라는 거짓말에요. 그러나 시장의 압박은 절대 수그러들지 않고 다음 기능, 또 다음 기능이 기다리고 있습니다.

결국 엉망진창 되어 생산성이 0에 수렴하게 됩니다. 이런 상황의 급하게 짜여진 코드가 쌓이면 새로운 기능을 개발하는 속도보다 과거의 코드를 유지보수하는 노력에 더 많은 인력이 투입됩니다.

개발자가 속는 더 잘못된 거짓말은 "지저분한 코드를 작성하면 단기간에 빠르게 갈 수 있고, 장기적으로 볼 때만 생산성이 낮아진다"입니다. 이건 개발자가 자신의 능력을 과신하게 됨으로써 진실을 오인하는 것이에요. 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리기 때문입니다.

소프트웨어 개발의 아주 단순한 진리는, **빨리 가는 유일한 방법은 제대로 가는 것**입니다. 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처 품질을 심각하게 고민하는 것입니다.

<br>

## 2장, 두 가지 가치에 대한 이야기
> 모든 소프트웨어 시스템은 행위(behavior)와 구조(structure) 두 가지 가치를 제공합니다.

소프트웨어 개발자는 두 가치를 반드시 높게 유지해야 하는 책임이 있습니다. 이 중 하나라도 배제하기 시작한다면 결국 소프트웨어 시스템이 쓸모없게 돼죠.

### 행위
프로그래머를 고용하는 이유? 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서죠. 많은 개발자가 이 활동이 자신에게 주어진 할 일의 전부라고 생각하는데, 이건 틀렸습니다.

<br>

### 아키텍처
소프트웨어(software)라는 단어는 부드러운(soft)과 제품(ware)의 합성어입니다. 제품은 당연히 상품(product), 부드러운은... 아마 이 단어에 두 번째 가치가 존재할 것입니다.

소프트웨어는 기계의 행위를 쉽게 변경하기 위해 `부드러움을 지니도록` 만들어졌습니다. 어렵게 변경한다면 그것은 하드웨어(hardware)이죠. 소프트웨어가 가진 본연의 목적을 추구하려면 반드시 **변경하기 쉬워야** 합니다.

이해관계자가 기능에 대한 생각을 바꾸면 이러한 변경사항을 간단하고 쉽게 적용할 수 있어야 합니다. 이런 변경사항을 적용하는 데 드는 어려움은 변경되는 범위(scope)에 비례하고, 변경사항의 형태(shape)와는 관련이 없어야 합니다.

새로운 요청사항이 발생할 때마다 이전의 변경사항을 적용하는 것보다 어려워지는 이유는 `시스템의 형태와 요구사항의 형태가 서로 맞지 않기 때문`입니다. 따라서 아키텍처는 형태에 독립적이어야만 더 실용적이게 됩니다.

<hr>

자, 가치가 높은 것은 기능일까요? 아니면 아키텍처일까요? 업무 관리자라면 소프트웨어 시스템이 동작하는 `기능`이 중요하다고 생각할 것이고, 개발자 또한 이 의견에 동조할 것입니다. 하지만 조금 극단적으로 생각해보자면...
- 완벽하게 동작해도 수정이 불가능한 프로그램이라면 요구사항이 변경되었을 때 동작하지 않고, 프로그램이 돌아가게 만들 수 없으니 거의 쓸모가 없다.

- 동작은 하지 않아도 변경이 쉬운 프로그램이라면 이를 돌아가게 만들 수 있고, 요구사항이 변경되어도 여전히 동작되게 유지보수할 수 있으니 이런 프로그램은 계속 유용하다.

미래에 업무 관리자의 변경 요청에 "변경 비용이 너무 커요. 불가능합니다"라고 대답한다면 "변경이 불가능한 상태에 처할 때까지 시스템을 방치했다"라며 의사소통이 힘들어질 수 있겠죠?

### 아이젠하워 매트릭스
> 내겐 두 가지 유형의 문제가 있습니다. 하나는 긴급하며, 다른 하나는 중요합니다. 긴급한 문제는 중요하지 않으며, 중요한 문제는 절대 긴급하지 않습니다.

소프트웨어의 첫 번째 가치인 행위는 `긴급하지만 매번 높은 중요도를 가지는 것은 아닙니다`. 두 번째 가치인 아키텍처는 `중요하지만 즉각적인 긴급성을 필요로 하는 경우는 절대 없습니다`. 그렇기에 우리는 이 두 가지에서 파생될 수 있는 네 가지 상황에 대해 결단을 내려야 해요.
1. 긴급하고 중요한
2. 긴급하지는 않지만 중요한
3. 긴급하지만 중요하지 않은
4. 긴급하지도 중요하지도 않은

아키텍처는 상위에, 행위는 하위에 위치하는 것을 볼 수 있나요? 업무 관리자와 개발자가 흔히 저지르는 실수는 3번째 위치한 항목을 첫 번째로 격상시키는 것입니다.

업무 관리자는 아키텍처의 중요성을 평가할 만한 능력을 겸비하지 못했으므로, 개발자는 딜레마에 빠지죠. 아이러니하게도 소프트웨어 개발자는 이런 딜레마를 해결하기 위해 고용하는 것입니다. 따라서 기능의 긴급성이 아닌 아키텍처의 중요성을 설득하는 일은 소프트웨어 개발팀이 마땅히 책임져야 합니다.

<hr>

효율적인 소프트웨어 개발팀은 싸움판에 뛰어들어야 합니다. 마케팅, 영업, 전략팀도 이미 자신들의 가치를 위해 투쟁하고 있어요. 효율적인 소프트웨어 개발팀은 뻔뻔함을 무릎쓰고 다른 이해관계자들과 동등하게 논쟁해야 합니다.

여러분은 소프트웨어를 안전하게 보호할 책임이 있으니까요. 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해집니다. 이런 상황이 발생하도록 용납하지 마세요. 개발팀이 스스로 옳다고 믿는 가치를 위해 충분히 투쟁하길 바랍니다.

<br>
